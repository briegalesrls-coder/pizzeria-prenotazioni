# =====================================================
# FREEZE v5 ‚Äî STATO CONSOLIDATO
# Non modificare questo file.
# Ogni sviluppo futuro va fatto su main.py
# =====================================================
from fastapi import FastAPI, Request, Form
from fastapi.responses import HTMLResponse, RedirectResponse, PlainTextResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from starlette.middleware.sessions import SessionMiddleware
from datetime import datetime, timedelta
from twilio.twiml.messaging_response import MessagingResponse
from pydantic import BaseModel
import json, os, uuid, re

app = FastAPI()

# =========================
# MIDDLEWARE
# =========================

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

app.add_middleware(
    SessionMiddleware,
    secret_key="cambia-questa-chiave"
)

# =========================
# CONFIG
# =========================
# =========================
# HARDENING
# =========================
SESSION_TIMEOUT_SEC = 300  # 5 minuti

DATA_FILE = "data/prenotazioni.json"

DASH_USER = "admin"
DASH_PASS = "pizza123"

MAX_COPERTI_PER_TURNO = 40

TURNI = {
    "turno_1": {"inizio": (19, 0), "fine": (19, 30)},
    "turno_2": {"inizio": (21, 30), "fine": (22, 0)},
}

prenotazioni = {}

# =========================
# PERSISTENZA
# =========================

def salva():
    os.makedirs("data", exist_ok=True)
    with open(DATA_FILE, "w", encoding="utf-8") as f:
        json.dump({"prenotazioni": prenotazioni}, f, ensure_ascii=False, indent=2)

def carica():
    global prenotazioni
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r", encoding="utf-8") as f:
            d = json.load(f)
            prenotazioni = d.get("prenotazioni", {})

carica()

# =========================
# UTILS
# =========================
PAROLE_DA_ESCLUDERE = {
    "ciao", "vorrei", "prenotare", "prenotazione",
    "siamo", "si", "no", "grazie", "buonasera",
    "salve", "per", "a", "alle"
}

def ora_serale(ora: str) -> str:
    """
    Converte 7:20 -> 19:20 nel contesto ristorante serale
    """
    h, m = map(int, ora.split(":"))

    # se √® un'ora "ambigua" (1‚Äì11), assumiamo sera
    if 1 <= h <= 11:
        h += 12

    return f"{h:02d}:{m:02d}"

def assegna_turno(ora):
    h, m = map(int, ora.split(":"))
    tot = h * 60 + m
    for k, v in TURNI.items():
        i = v["inizio"][0] * 60 + v["inizio"][1]
        f = v["fine"][0] * 60 + v["fine"][1]
        if i <= tot <= f:
            return k
    return None

def descrivi_turni():
    righe = []
    for v in TURNI.values():
        h1, m1 = v["inizio"]
        h2, m2 = v["fine"]
        righe.append(f"{h1:02d}:{m1:02d}‚Äì{h2:02d}:{m2:02d}")
    return " / ".join(righe)

def normalizza_ora(ora: str) -> str | None:
    try:
        h, m = ora.split(":")
        h, m = int(h), int(m)
        if 0 <= h <= 23 and 0 <= m <= 59:
            return f"{h:02d}:{m:02d}"
    except Exception:
        pass
    return None



def estrai_nome_cognome(t):
    t = t.lower().strip()
    parole = t.split()

    if len(parole) < 2:
        return None, None

    p1, p2 = parole[0], parole[1]

    if (
        p1 in PAROLE_DA_ESCLUDERE or
        p2 in PAROLE_DA_ESCLUDERE or
        not p1.isalpha() or
        not p2.isalpha()
    ):
        return None, None

    return p1.capitalize(), p2.capitalize()

def ora_valida(ora: str) -> bool:
    if not ora:
        return False
    return assegna_turno(ora) is not None


def estrai_numero(t):
    m = re.search(r"\b3\d{8,9}\b", t)
    return m.group(0) if m else None

def estrai_persone(t: str) -> int | None:
    t = t.lower().strip()

    # caso esplicito: "2 persone", "2 pax"
    m = re.search(r"\b(\d{1,2})\s*(persone|pax)\b", t)
    if m:
        return int(m.group(1))

    # numero secco: "2"
    if t.isdigit():
        n = int(t)
        if 1 <= n <= 20:
            return n

    # fallback: "siamo in 2"
    m = re.search(r"\b(\d{1,2})\b", t)
    if m:
        n = int(m.group(1))
        if 1 <= n <= 20:
            return n

    return None


def stato_completo(s: dict) -> bool:
    return all([
        s.get("nome"),
        s.get("cognome"),
        s.get("persone"),
        s.get("data"),
        ora_valida(s.get("ora")),
        s.get("telefono"),
    ])


def estrai_ora(t: str, accetta_numero_secco: bool = False) -> str | None:
    t = t.lower().strip()

    # HH:MM o H.MM
    m = re.search(r"\b(\d{1,2})[:\.](\d{2})\b", t)
    if m:
        h, mnt = int(m.group(1)), int(m.group(2))
        if 0 <= h <= 23 and 0 <= mnt <= 59:
            return f"{h:02d}:{mnt:02d}"

    # NUMERO SECCO ‚Üí SOLO SE PERMESSO
    if accetta_numero_secco:
        m = re.search(r"\b(\d{1,2})\b", t)
        if m:
            h = int(m.group(1))
            if 0 <= h <= 23:
                return f"{h:02d}:00"

    return None


GIORNI_SETTIMANA = {
    "lunedi": 0, "luned√¨": 0,
    "martedi": 1, "marted√¨": 1,
    "mercoledi": 2, "mercoled√¨": 2,
    "giovedi": 3, "gioved√¨": 3,
    "venerdi": 4, "venerd√¨": 4,
    "sabato": 5,
    "domenica": 6,
}

MESI = {
    "gennaio": 1, "febbraio": 2, "marzo": 3,
    "aprile": 4, "maggio": 5, "giugno": 6,
    "luglio": 7, "agosto": 8,
    "settembre": 9, "ottobre": 10,
    "novembre": 11, "dicembre": 12,
}


def estrai_data(t: str) -> str | None:
    t = t.lower()
    oggi = datetime.now().date()

    # =========================
    #1Ô∏è‚É£ oggi / domani / dopodomani
    # =========================
    if "oggi" in t:
        return oggi.isoformat()

    if "dopodomani" in t:
        return (oggi + timedelta(days=2)).isoformat()

    if "domani" in t:
        return (oggi + timedelta(days=1)).isoformat()

    # =========================
    # 2Ô∏è‚É£ giorni della settimana
    # =========================
    for nome, idx in GIORNI_SETTIMANA.items():
        if nome in t:
            delta = (idx - oggi.weekday()) % 7
            if delta == 0 or "prossimo" in t:
                delta += 7
            return (oggi + timedelta(days=delta)).isoformat()

    # =========================
    # 3Ô∏è‚É£ formato numerico 02/06(/2026)
    # =========================
    m = re.search(r"\b(\d{1,2})/(\d{1,2})(?:/(\d{2,4}))?\b", t)
    if m:
        g, mth, y = m.groups()
        g, mth = int(g), int(mth)
        y = int(y) if y else oggi.year
        if y < 100:
            y += 2000
        try:
            d = datetime(y, mth, g).date()
            if d < oggi:
                d = datetime(y + 1, mth, g).date()
            return d.isoformat()
        except ValueError:
            pass

    # =========================
    # 4Ô∏è‚É£ formato testuale "2 giugno"
    # =========================
    m = re.search(r"\b(\d{1,2})\s+([a-z]+)(?:\s+(\d{4}))?\b", t)
    if m:
        g, mese_txt, y = m.groups()
        mese = MESI.get(mese_txt)
        if mese:
            y = int(y) if y else oggi.year
            try:
                d = datetime(y, mese, int(g)).date()
                if d < oggi:
                    d = datetime(y + 1, mese, int(g)).date()
                return d.isoformat()
            except ValueError:
                pass

    # =========================
    # fallback
    # =========================
    return None

# =========================
# CORE PRENOTAZIONE
# =========================

def crea_prenotazione(nome, cognome, telefono, data, ora, persone, fonte):
    turno = assegna_turno(ora)
    if not turno:
        return False, "‚õî Orario non disponibile."

    prenotazioni.setdefault(data, {}).setdefault(turno, [])
    # controllo capienza turno
    coperti = sum(
        p["persone"]
        for p in prenotazioni[data][turno]
        if p["stato"] == "attiva"
    )

    if coperti + persone > MAX_COPERTI_PER_TURNO:
        altri_turni = turni_disponibili(data, persone)

        if altri_turni:
            return False, (
            "‚õî Purtroppo il turno scelto √® al completo.\n"
            f"Possiamo proporre questi orari disponibili: {' / '.join(altri_turni)}.\n"
            "Quale preferisce?"
            )

        return False, (
        "‚õî Purtroppo per questo giorno siamo al completo.\n"
        "Vuole scegliere un altro giorno?"
        )


    pren = {
        "id": str(uuid.uuid4()),
        "nome": nome,
        "cognome": cognome,
        "telefono": telefono,
        "data": data,
        "ora": ora,
        "turno": turno,
        "persone": persone,
        "fonte": fonte,
        "stato": "attiva",
        "timestamp": datetime.now().isoformat()
    }

    prenotazioni[data][turno].append(pren)
    salva()

    return True, (
        f"‚úÖ Prenotazione confermata\n\n"
        f"{nome} {cognome}\n"
        f"üìÖ {data}\nüï§ {ora}\n"
        f"üë• {persone} persone\n"
        f"üìû {telefono}"
    )

# =========================
# WHATSAPP TWILIO
# =========================

@app.post("/whatsapp/twilio")
async def whatsapp_twilio(req: Request):
    form = await req.form()
    body = form.get("Body", "")
    body_l = body.lower()

    nome, cognome = estrai_nome_cognome(body)
    telefono = estrai_numero(body_l)
    persone = estrai_persone(body_l)
    ora = estrai_ora(body_l)
    data = estrai_data(body_l)

    resp = MessagingResponse()

    if not nome or not cognome:
        resp.message("‚úçÔ∏è Indica nome e cognome.")
        return PlainTextResponse(str(resp))

    if not telefono or not persone or not ora:
        resp.message("Messaggio incompleto.")
        return PlainTextResponse(str(resp))

    ok, msg = crea_prenotazione(
        nome, cognome, telefono, data, ora, persone, "whatsapp"
    )

    resp.message(msg)
    return PlainTextResponse(str(resp))

# =========================
# LOGIN
# =========================

@app.get("/login", response_class=HTMLResponse)
def login_page():
    return """
    <h2>Login Dashboard</h2>
    <form method="post">
      <input name="username" placeholder="Username"><br><br>
      <input name="password" type="password" placeholder="Password"><br><br>
      <button>Entra</button>
    </form>
    """

@app.post("/login")
def login(request: Request, username: str = Form(...), password: str = Form(...)):
    if username == DASH_USER and password == DASH_PASS:
        request.session["logged"] = True
        return RedirectResponse("/dashboard", status_code=302)
    return HTMLResponse("Credenziali errate")

# =========================
# DASHBOARD
# =========================

@app.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request):
    if not request.session.get("logged"):
        return RedirectResponse("/login", status_code=302)

    return """
<!DOCTYPE html>
<html>
<head>
  <style>
    body{font-family:Arial;padding:20px}
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid #ccc;padding:6px}
    .attiva{background:#d4edda}
    .annullata{background:#f8d7da}
    input,select{width:95%}
  </style>
</head>
<body>

<h1>Dashboard Prenotazioni</h1>

<input id="data">
<button onclick="oggi()">Oggi</button>
<button onclick="domani()">Domani</button>

<br><br>

<input id="search" placeholder="Cerca nome / cognome / telefono">
<select id="filtro">
  <option value="">Tutti</option>
  <option value="attiva">Attive</option>
  <option value="annullata">Annullate</option>
</select>
<button onclick="carica()">Carica</button>

<table>
<thead>
<tr>
<th>Nome</th><th>Cognome</th><th>Telefono</th>
<th>Ora</th><th>Persone</th><th>Stato</th><th>Azioni</th>
</tr>
</thead>
<tbody id="tbody"></tbody>
</table>

<script>
function oggi(){ data.value=new Date().toISOString().slice(0,10); carica(); }
function domani(){ const d=new Date(); d.setDate(d.getDate()+1); data.value=d.toISOString().slice(0,10); carica(); }

async function carica(){
  const r = await fetch('/dashboard/lista?data='+data.value);
  let d = await r.json();

  const q = search.value.toLowerCase();
  const f = filtro.value;

  d = d.filter(p =>
    (!q || (p.nome+p.cognome+p.telefono).toLowerCase().includes(q)) &&
    (!f || p.stato===f)
  );

  tbody.innerHTML='';
  d.forEach(p=>{
    tbody.innerHTML+=`
    <tr class="${p.stato}">
      <td><input id="n_${p.id}" value="${p.nome}"></td>
      <td><input id="c_${p.id}" value="${p.cognome}"></td>
      <td><input id="t_${p.id}" value="${p.telefono}"></td>
      <td><input id="o_${p.id}" value="${p.ora}"></td>
      <td><input id="p_${p.id}" type="number" value="${p.persone}"></td>
      <td>${p.stato}</td>
      <td>
        ${p.stato==='attiva'
          ? `<button onclick="modifica('${p.id}')">Modifica</button>
             <button onclick="annulla('${p.id}')">Annulla</button>`
          : ''}
      </td>
    </tr>`;
  });
}

async function modifica(id){
  await fetch('/dashboard/modifica',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({
      id,
      nome:document.getElementById('n_'+id).value,
      cognome:document.getElementById('c_'+id).value,
      telefono:document.getElementById('t_'+id).value,
      ora:document.getElementById('o_'+id).value,
      persone:parseInt(document.getElementById('p_'+id).value)
    })
  });
  carica();
}

async function annulla(id){
  if(!confirm("Annullare la prenotazione?")) return;
  await fetch('/dashboard/annulla',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({id})
  });
  carica();
}
</script>

</body>
</html>
"""

@app.get("/dashboard/lista")
def lista(data: str):
    out=[]
    for t in prenotazioni.get(data,{}):
        out.extend(prenotazioni[data][t])
    return out

@app.post("/dashboard/modifica")
async def modifica(req: Request):
    b = await req.json()
    for d in prenotazioni:
        for t in prenotazioni[d]:
            for p in prenotazioni[d][t]:
                if p["id"]==b["id"] and p["stato"]=="attiva":
                    p.update({
                        "nome":b["nome"],
                        "cognome":b["cognome"],
                        "telefono":b["telefono"],
                        "ora":b["ora"],
                        "persone":b["persone"]
                    })
                    salva()
                    return {"ok":True}
    return {"ok":False}

@app.post("/dashboard/annulla")
async def annulla(req: Request):
    b = await req.json()
    for d in prenotazioni:
        for t in prenotazioni[d]:
            for p in prenotazioni[d][t]:
                if p["id"]==b["id"]:
                    p["stato"]="annullata"
                    salva()
                    return {"ok":True}
    return {"ok":False}
# =========================
# UTILS
# =========================

def cleanup_voice_sessions():
    now = datetime.now().timestamp()
    scadute = [
        sid for sid, s in voice_sessions.items()
        if now - s.get("last_seen", now) > SESSION_TIMEOUT_SEC
    ]
    for sid in scadute:
        del voice_sessions[sid]

def applica_modifiche_da_testo(s, testo):
    """
    Ritorna True se almeno un campo √® stato modificato
    """
    modificato = False
    t = testo.lower()

    # persone
    p = estrai_persone(t)
    if p and p != s.get("persone"):
        s["persone"] = p
        modificato = True

    # data
    d = estrai_data(t)
    if d and d != s.get("data"):
        s["data"] = d
        modificato = True

    # ora
    o = estrai_ora(t, accetta_numero_secco=True)
    if o:
        o = normalizza_ora(o)
        o = ora_serale(o)
        if o and o != s.get("ora"):
            s["ora"] = o
            modificato = True

    return modificato

def turni_disponibili(data: str, persone: int) -> list[str]:
    disponibili = []

    for turno, v in TURNI.items():
        prenotazioni.setdefault(data, {}).setdefault(turno, [])

        coperti = sum(
            p["persone"]
            for p in prenotazioni[data][turno]
            if p["stato"] == "attiva"
        )

        if coperti + persone <= MAX_COPERTI_PER_TURNO:
            h1, m1 = v["inizio"]
            h2, m2 = v["fine"]
            disponibili.append(
                f"{h1:02d}:{m1:02d}‚Äì{h2:02d}:{m2:02d}"
            )

    return disponibili

# =========================
# VOICE TEST (STEP 1)
# =========================

voice_sessions = {}

def gestisci_voice_test(session_id: str, testo: str):
    # =========================
    # HARDENING: CLEANUP SESSIONI SCADUTE
    # =========================
    cleanup_voice_sessions()

    # =========================
    # HARDENING: INPUT VUOTO
    # =========================
    if not testo or not testo.strip():
        return "Non ho sentito nulla. Pu√≤ ripetere, per favore?"

    testo_l = testo.lower()

    # =========================
    # SESSIONE
    # =========================
    now = datetime.now().timestamp()

    s = voice_sessions.setdefault(session_id, {
        "nome": None,
        "cognome": None,
        "telefono": None,
        "data": None,
        "ora": None,
        "persone": None,
        "attesa_conferma": False,
        "last_seen": now
    })

    # =========================
    # HARDENING: TIMEOUT SESSIONE
    # =========================
    if now - s.get("last_seen", now) > SESSION_TIMEOUT_SEC:
        voice_sessions.pop(session_id, None)
        return (
            "La chiamata precedente √® scaduta.\n"
            "Ripartiamo da capo: mi dica nome e cognome per la prenotazione."
        )

    # aggiorna sempre l‚Äôultimo accesso
    s["last_seen"] = now
   

    # =========================
    #1Ô∏è‚É£ ESTRAZIONI CONTESTUALI
    # =========================
    if not s["nome"] or not s["cognome"]:
        n, c = estrai_nome_cognome(testo)
        if n and c:
            s["nome"] = n
            s["cognome"] = c

    if not s["persone"]:
     p = estrai_persone(testo)
     if p:
        s["persone"] = p
        return f"Perfetto, {p} persone. Per che giorno desidera prenotare?"


    elif not s["data"]:
        d = estrai_data(testo)
        if d:
            s["data"] = d

    elif not ora_valida(s["ora"]):
        o = estrai_ora(testo, accetta_numero_secco=True)
        o = normalizza_ora(o) if o else None
        if o:
            o = ora_serale(o)
            s["ora"] = o

    elif not s["telefono"]:
        tel = estrai_numero(testo)
        if tel:
            s["telefono"] = tel

    # =========================
    # 2Ô∏è‚É£ GUIDA CONVERSAZIONALE
    # =========================
    if not s["nome"] or not s["cognome"]:
        return "Mi dica nome e cognome per la prenotazione."

    if not s["persone"]:
        return "Per quante persone desidera prenotare?"

    if not s["data"]:
        return "Per che giorno desidera prenotare?"

    if not ora_valida(s["ora"]):
        return f"A che ora desidera prenotare? Accettiamo: {descrivi_turni()}."

    if not s["telefono"]:
        return "Mi lascia un numero di telefono?"

    # =========================
    # 3Ô∏è‚É£ RIEPILOGO + CONFERMA
    # =========================
    if not s["attesa_conferma"]:
        s["attesa_conferma"] = True
        data_txt = datetime.fromisoformat(s["data"]).strftime("%d/%m/%Y")
    return (
        "Perfetto, riepilogo la prenotazione:\n\n"
        f"üë§ {s['nome']} {s['cognome']}\n"
        f"üë• {s['persone']} persone\n"
        f"üìÖ {data_txt}\n"
        f"üï¢ {s['ora']} (turni: {descrivi_turni()})\n"
        f"üìû {s['telefono']}\n\n"
        "Conferma la prenotazione? (s√¨ / no)"
    )

 # =========================
 #  4Ô∏è‚É£ RISPOSTA ALLA CONFERMA
 # =========================
    if s.get("attesa_conferma"):
        t = testo_l

        if t in {"si", "s√¨", "confermo", "ok"}:
            ok, msg = crea_prenotazione(
                s["nome"],
                s["cognome"],
                s["telefono"],
                s["data"],
                s["ora"],
                s["persone"],
                fonte="voice_test"
            )
            s["attesa_conferma"] = False
            return msg

        if t in {"no", "modifica", "cambia"}:
            s["attesa_conferma"] = False
            s["ora"] = None
            return "Va bene. Cosa desidera modificare?"

 # =========================
 # üîÅ MODIFICA NATURALE
 # =========================

    if applica_modifiche_da_testo(s, testo):
        data_txt = datetime.fromisoformat(s["data"]).strftime("%d/%m/%Y")
        return (
            "Perfetto, aggiorno il riepilogo:\n\n"
            f"üë§ {s['nome']} {s['cognome']}\n"
            f"üë• {s['persone']} persone\n"
            f"üìÖ {data_txt}\n"
            f"üï¢ {s['ora']}\n"
            f"üìû {s['telefono']}\n\n"
            "Conferma la prenotazione? (s√¨ / no)"
        )

    return "Dimmi cosa vuoi modificare (persone, giorno o orario)."
# =========================
# VOICE TEST SCHEMA
# =========================

class VoiceTestRequest(BaseModel):
    session_id: str
    text: str

@app.post("/voice/test")
async def voice_test(body: VoiceTestRequest):
    session_id = body.session_id
    text = body.text

    if not session_id:
        return JSONResponse(
            {"error": "session_id mancante"},
            status_code=400
        )

    reply = gestisci_voice_test(session_id, text)

    return {"reply": reply}
# =========================
# VOICE TWILIO
# =========================

from twilio.twiml.voice_response import VoiceResponse

@app.post("/voice")
async def voice(req: Request):
    form = await req.form()

    call_sid = form.get("CallSid")
    speech = form.get("SpeechResult", "").strip()

    vr = VoiceResponse()

    # =========================
    # PRIMA INTERAZIONE
    # =========================
    if not speech:
        vr.say(
            "Buonasera, sono l'assistente della pizzeria. "
            "Vuole prenotare un tavolo?",
            language="it-IT",
            voice="alice"
        )
    else:
        reply = gestisci_voice_test(call_sid, speech)
        vr.say(reply, language="it-IT", voice="alice")

    # =========================
    # CONTINUA ASCOLTO
    # =========================
    vr.gather(
        input="speech",
        language="it-IT",
        action="/voice",
        method="POST",
        timeout=5
    )

    return PlainTextResponse(str(vr))


